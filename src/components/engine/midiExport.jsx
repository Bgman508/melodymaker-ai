// Professional MIDI File Writer (SMF Type-1, PPQ=480)
export class MIDIWriter {
  constructor() {
    this.ppq = 480; // Ticks per quarter note
  }

  writeVarLength(value) {
    const bytes = [];
    bytes.push(value & 0x7F);
    value >>= 7;
    while (value > 0) {
      bytes.unshift((value & 0x7F) | 0x80);
      value >>= 7;
    }
    return bytes;
  }

  writeMetaTrack(bpm, timeSignature = '4/4', copyright = 'Generated by Prompt2MIDI Studio Pro') {
    const events = [];
    const [numerator, denominator] = timeSignature.split('/').map(Number);
    const microsecondsPerBeat = Math.floor(60000000 / bpm);
    
    // Tempo event (0x51)
    events.push({
      time: 0,
      data: [0xFF, 0x51, 0x03, 
             (microsecondsPerBeat >> 16) & 0xFF,
             (microsecondsPerBeat >> 8) & 0xFF,
             microsecondsPerBeat & 0xFF]
    });
    
    // Time signature (0x58)
    events.push({
      time: 0,
      data: [0xFF, 0x58, 0x04, numerator, Math.log2(denominator), 24, 8]
    });
    
    // Copyright (0x02)
    if (copyright) {
      const copyrightBytes = Array.from(copyright).map(c => c.charCodeAt(0));
      events.push({
        time: 0,
        data: [0xFF, 0x02, copyrightBytes.length, ...copyrightBytes]
      });
    }
    
    // Track name (0x03)
    const trackName = "Meta Track";
    const nameBytes = Array.from(trackName).map(c => c.charCodeAt(0));
    events.push({
      time: 0,
      data: [0xFF, 0x03, nameBytes.length, ...nameBytes]
    });
    
    // End of track (0x2F)
    events.push({
      time: this.ppq * 4,
      data: [0xFF, 0x2F, 0x00]
    });
    
    return this.buildTrackData(events);
  }

  writeMusicalTrack(track, bpm, sectionOverrides = null) {
    const events = [];
    
    // Track name (0x03)
    const nameBytes = Array.from(track.name).map(c => c.charCodeAt(0));
    events.push({
      time: 0,
      data: [0xFF, 0x03, nameBytes.length, ...nameBytes]
    });
    
    // Program change at time 0 (0xC0) - NOT for drum channel (9)
    if (track.channel !== 9 && track.program !== undefined) {
      events.push({
        time: 0,
        data: [0xC0 | track.channel, track.program & 0x7F]
      });
    }
    
    // Add section-specific program changes if provided
    if (sectionOverrides && track.channel !== 9) {
      sectionOverrides.forEach(override => {
        if (override.program !== undefined) {
          const sectionStartTick = Math.round(override.startBeat * this.ppq);
          events.push({
            time: sectionStartTick,
            data: [0xC0 | track.channel, override.program & 0x7F]
          });
        }
      });
    }
    
    // Convert notes to events
    const noteEvents = [];
    track.notes.forEach(note => {
      const startTick = Math.round(note.start * this.ppq);
      const endTick = Math.round((note.start + note.duration) * this.ppq);
      
      // Note On (0x90)
      noteEvents.push({
        time: startTick,
        data: [0x90 | track.channel, Math.floor(note.pitch), Math.floor(note.velocity)]
      });
      
      // Note Off (0x80)
      noteEvents.push({
        time: endTick,
        data: [0x80 | track.channel, Math.floor(note.pitch), 64]
      });
    });
    
    // Add pitch bends for 808 slides (0xE0)
    if (track.pitchBends) {
      track.pitchBends.forEach(bend => {
        const tick = Math.round(bend.time * this.ppq);
        const lsb = bend.value & 0x7F;
        const msb = (bend.value >> 7) & 0x7F;
        noteEvents.push({
          time: tick,
          data: [0xE0 | track.channel, lsb, msb]
        });
      });
    }
    
    // Sort all events by time
    noteEvents.sort((a, b) => a.time - b.time);
    events.push(...noteEvents);
    
    // End of track (0x2F)
    const lastTime = noteEvents.length > 0 ? noteEvents[noteEvents.length - 1].time + 100 : 100;
    events.push({
      time: lastTime,
      data: [0xFF, 0x2F, 0x00]
    });
    
    return this.buildTrackData(events);
  }

  buildTrackData(events) {
    const trackData = [];
    let currentTime = 0;
    
    events.forEach(event => {
      const deltaTime = Math.max(0, event.time - currentTime);
      trackData.push(...this.writeVarLength(deltaTime));
      trackData.push(...event.data);
      currentTime = event.time;
    });
    
    return new Uint8Array(trackData);
  }

  exportMIDI(tracks, bpm, timeSignature = '4/4', type = 1, copyright = 'Generated by Prompt2MIDI Studio Pro', sectionOverrides = null) {
    const trackCount = type === 1 ? tracks.length + 1 : 1; // +1 for meta track in Type-1
    
    // Header chunk
    const header = new Uint8Array([
      0x4D, 0x54, 0x68, 0x64, // "MThd"
      0x00, 0x00, 0x00, 0x06, // Header length (6 bytes)
      0x00, type,             // Format type
      (trackCount >> 8) & 0xFF, trackCount & 0xFF, // Number of tracks
      (this.ppq >> 8) & 0xFF, this.ppq & 0xFF     // Division (PPQ)
    ]);
    
    const trackChunks = [];
    
    // Add meta track for Type-1
    if (type === 1) {
      const metaData = this.writeMetaTrack(bpm, timeSignature, copyright);
      const metaHeader = new Uint8Array([
        0x4D, 0x54, 0x72, 0x6B, // "MTrk"
        (metaData.length >> 24) & 0xFF,
        (metaData.length >> 16) & 0xFF,
        (metaData.length >> 8) & 0xFF,
        metaData.length & 0xFF
      ]);
      trackChunks.push(new Uint8Array([...metaHeader, ...metaData]));
    }
    
    // Add musical tracks
    tracks.forEach(track => {
      const trackData = this.writeMusicalTrack(track, bpm, sectionOverrides?.[track.type]);
      const trackHeader = new Uint8Array([
        0x4D, 0x54, 0x72, 0x6B, // "MTrk"
        (trackData.length >> 24) & 0xFF,
        (trackData.length >> 16) & 0xFF,
        (trackData.length >> 8) & 0xFF,
        trackData.length & 0xFF
      ]);
      trackChunks.push(new Uint8Array([...trackHeader, ...trackData]));
    });
    
    // Combine all chunks
    let totalLength = header.length;
    trackChunks.forEach(chunk => totalLength += chunk.length);
    
    const midi = new Uint8Array(totalLength);
    let offset = 0;
    
    midi.set(header, offset);
    offset += header.length;
    
    trackChunks.forEach(chunk => {
      midi.set(chunk, offset);
      offset += chunk.length;
    });
    
    return midi;
  }

  downloadMIDI(tracks, bpm, filename = 'composition.mid', timeSignature = '4/4', copyright) {
    const midiData = this.exportMIDI(tracks, bpm, timeSignature, 1, copyright);
    const blob = new Blob([midiData], { type: 'audio/midi' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  }

  downloadStems(tracks, bpm, projectName = 'project', timeSignature = '4/4') {
    tracks.forEach(track => {
      // Export each stem as Type-0 for max compatibility
      const midiData = this.exportMIDI([track], bpm, timeSignature, 0);
      const blob = new Blob([midiData], { type: 'audio/midi' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${projectName}_${track.name}_stem.mid`;
      a.click();
      URL.revokeObjectURL(url);
    });
  }

  async downloadZip(tracks, bpm, projectName = 'project', timeSignature = '4/4', dawTemplate) {
    // Create project info JSON
    const projectInfo = {
      name: projectName,
      bpm,
      timeSignature,
      trackCount: tracks.length,
      totalNotes: tracks.reduce((sum, t) => sum + t.notes.length, 0),
      dawTemplate,
      exportDate: new Date().toISOString()
    };

    // For now, download files separately (full implementation would use JSZip)
    this.downloadMIDI(tracks, bpm, `${projectName}_complete.mid`, timeSignature, `Project: ${projectName}`);
    this.downloadStems(tracks, bpm, projectName, timeSignature);
    
    // Download project info
    const infoBlob = new Blob([JSON.stringify(projectInfo, null, 2)], { type: 'application/json' });
    const infoUrl = URL.createObjectURL(infoBlob);
    const a = document.createElement('a');
    a.href = infoUrl;
    a.download = `${projectName}_info.json`;
    a.click();
    URL.revokeObjectURL(infoUrl);
  }
}